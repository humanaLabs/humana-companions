---
description:
globs:
alwaysApply: false
---
# Humana Companions - Tratamento de Erros Obrigat√≥rio

## Princ√≠pio Fundamental
**TODO c√≥digo que pode falhar DEVE ter tratamento de erro adequado.** Nunca deixe erros n√£o tratados.

## Regras Obrigat√≥rias

### üö® SEMPRE Trate Erros
- Todas as chamadas de API
- Opera√ß√µes de arquivo/banco de dados
- Parsing de JSON
- Valida√ß√µes de entrada
- Opera√ß√µes ass√≠ncronas
- Integra√ß√µes externas

### ‚úÖ Padr√µes de Tratamento

#### 1. API Calls - Sempre com Try/Catch
```typescript
// ‚ùå RUIM - Sem tratamento
export async function fetchAgents() {
  const response = await fetch('/api/agents')
  return response.json()
}

// ‚úÖ BOM - Tratamento completo
export async function fetchAgents(): Promise<Agent[]> {
  try {
    const response = await fetch('/api/agents')
    
    if (!response.ok) {
      throw new Error(`HTTP ${response.status}: ${response.statusText}`)
    }
    
    const data = await response.json()
    
    // Valida√ß√£o dos dados
    if (!Array.isArray(data.agents)) {
      throw new Error('Invalid response format: agents must be an array')
    }
    
    return data.agents
  } catch (error) {
    console.error('Error fetching agents:', error)
    
    // Re-throw com contexto
    throw new Error(
      `Failed to fetch agents: ${error instanceof Error ? error.message : 'Unknown error'}`
    )
  }
}
```

#### 2. Componentes React - Error Boundaries
```typescript
// ‚úÖ Sempre wrap componentes cr√≠ticos
export function AgentSelector({ onSelect }: Props) {
  const [agents, setAgents] = useState<Agent[]>([])
  const [error, setError] = useState<string>('')
  const [loading, setLoading] = useState(false)

  const loadAgents = useCallback(async () => {
    try {
      setLoading(true)
      setError('')
      
      const data = await fetchAgents()
      setAgents(data)
    } catch (error) {
      const message = error instanceof Error ? error.message : 'Failed to load agents'
      setError(message)
      console.error('AgentSelector error:', error)
    } finally {
      setLoading(false)
    }
  }, [])

  if (error) {
    return (
      <div className="error-state">
        <p>‚ùå {error}</p>
        <button onClick={loadAgents}>Tentar Novamente</button>
      </div>
    )
  }

  // ... resto do componente
}
```

#### 3. API Routes - Status Codes Corretos
```typescript
// ‚úÖ Tratamento completo em API routes
export async function GET() {
  try {
    const agents = await fetchAgentsFromDB()
    
    return NextResponse.json({ 
      success: true,
      agents 
    })
  } catch (error) {
    console.error('API Error:', error)
    
    // Diferentes tipos de erro
    if (error instanceof ValidationError) {
      return NextResponse.json(
        { success: false, error: error.message },
        { status: 400 }
      )
    }
    
    if (error instanceof AuthenticationError) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }
    
    // Erro gen√©rico
    return NextResponse.json(
      { success: false, error: 'Internal server error' },
      { status: 500 }
    )
  }
}
```

#### 4. Valida√ß√£o de Entrada
```typescript
// ‚úÖ Sempre valide entradas
export function validateAgentConfig(config: unknown): AgentConfig {
  if (!config || typeof config !== 'object') {
    throw new Error('Agent config must be an object')
  }
  
  const { name, model, apiKey } = config as any
  
  if (!name || typeof name !== 'string') {
    throw new Error('Agent name is required and must be a string')
  }
  
  if (!model || typeof model !== 'string') {
    throw new Error('Agent model is required and must be a string')
  }
  
  if (!apiKey || typeof apiKey !== 'string') {
    throw new Error('Agent API key is required and must be a string')
  }
  
  return { name, model, apiKey }
}
```

#### 5. Parsing Seguro
```typescript
// ‚ùå RUIM - Parsing sem tratamento
const config = JSON.parse(process.env.AGENT_CONFIG)

// ‚úÖ BOM - Parsing seguro
function parseAgentConfig(configString: string): AgentConfig[] {
  try {
    const parsed = JSON.parse(configString)
    
    if (!Array.isArray(parsed)) {
      throw new Error('Config must be an array')
    }
    
    return parsed.map(validateAgentConfig)
  } catch (error) {
    console.error('Failed to parse agent config:', error)
    
    // Fallback para configura√ß√£o padr√£o
    return getDefaultAgentConfig()
  }
}
```

## Tipos de Erro Padronizados

### Hierarquia de Erros Customizados
```typescript
// Base error class
export class HumanaError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 500
  ) {
    super(message)
    this.name = this.constructor.name
  }
}

// Erros espec√≠ficos
export class ValidationError extends HumanaError {
  constructor(message: string) {
    super(message, 'VALIDATION_ERROR', 400)
  }
}

export class AuthenticationError extends HumanaError {
  constructor(message: string = 'Authentication required') {
    super(message, 'AUTH_ERROR', 401)
  }
}

export class APIError extends HumanaError {
  constructor(message: string, statusCode: number = 500) {
    super(message, 'API_ERROR', statusCode)
  }
}

export class ConfigurationError extends HumanaError {
  constructor(message: string) {
    super(message, 'CONFIG_ERROR', 500)
  }
}
```

## Logging de Erros

### Estrutura Padr√£o
```typescript
// ‚úÖ Log estruturado
export function logError(error: Error, context: Record<string, any> = {}) {
  const errorInfo = {
    timestamp: new Date().toISOString(),
    message: error.message,
    stack: error.stack,
    name: error.name,
    ...context
  }
  
  console.error('üö® Error:', JSON.stringify(errorInfo, null, 2))
  
  // Em produ√ß√£o, enviar para servi√ßo de monitoramento
  if (process.env.NODE_ENV === 'production') {
    // sendToMonitoringService(errorInfo)
  }
}

// Uso
try {
  await riskyOperation()
} catch (error) {
  logError(error, {
    operation: 'fetchAgents',
    userId: user.id,
    timestamp: Date.now()
  })
  throw error
}
```

## Error Boundaries React

### Componente Padr√£o
```typescript
// components/error-boundary.tsx
interface ErrorBoundaryState {
  hasError: boolean
  error?: Error
}

export class ErrorBoundary extends Component<
  PropsWithChildren<{}>,
  ErrorBoundaryState
> {
  constructor(props: PropsWithChildren<{}>) {
    super(props)
    this.state = { hasError: false }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    logError(error, { errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="error-boundary">
          <h2>üö® Algo deu errado</h2>
          <p>Ocorreu um erro inesperado. Nossa equipe foi notificada.</p>
          <button onClick={() => window.location.reload()}>
            Recarregar P√°gina
          </button>
        </div>
      )
    }

    return this.props.children
  }
}
```

## Checklist de Tratamento de Erros

### Para cada fun√ß√£o/componente, verificar:
- [ ] Todas as opera√ß√µes ass√≠ncronas t√™m try/catch
- [ ] Status HTTP verificados em chamadas de API
- [ ] Valida√ß√£o de entrada implementada
- [ ] Mensagens de erro s√£o informativas
- [ ] Logs estruturados est√£o sendo gerados
- [ ] Fallbacks est√£o definidos quando poss√≠vel
- [ ] Error boundaries envolvem componentes cr√≠ticos
- [ ] Erros s√£o re-thrown com contexto adicional

## Padr√µes por Tipo de C√≥digo

### Hooks Customizados
```typescript
export function useAgents() {
  const [state, setState] = useState({
    agents: [],
    loading: false,
    error: null
  })

  const fetchAgents = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, loading: true, error: null }))
      const agents = await fetchAgentsAPI()
      setState(prev => ({ ...prev, agents, loading: false }))
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error'
      setState(prev => ({ ...prev, error: errorMessage, loading: false }))
      logError(error, { hook: 'useAgents' })
    }
  }, [])

  return { ...state, fetchAgents }
}
```

### Utility Functions
```typescript
export function safeParseJSON<T>(json: string, fallback: T): T {
  try {
    return JSON.parse(json)
  } catch (error) {
    logError(error, { json, fallback })
    return fallback
  }
}
```

## Lembre-se
- Erros n√£o tratados quebram a experi√™ncia do usu√°rio
- Sempre forne√ßa feedback visual para erros
- Logs estruturados facilitam debugging
- Fallbacks mant√™m a aplica√ß√£o funcionando
- Nunca falhe silenciosamente

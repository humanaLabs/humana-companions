# ğŸ—ï¸ HUMANA COMPANIONS - PADRÃ•ES DE ARQUITETURA E DESENVOLVIMENTO

**VersÃ£o:** 2.0  
**Data:** 30-1-2025  
**AplicaÃ§Ã£o:** Todas as mudanÃ§as no cÃ³digo devem seguir RIGOROSAMENTE estas diretrizes  
**ReferÃªncia:** ImplementaÃ§Ã£o do Service Layer Pattern e Isolamento de Responsabilidades

---

## ğŸ¯ **PRINCÃPIOS FUNDAMENTAIS**

### **1. MULTI-TENANCY RIGOROSO**
- **SEMPRE** incluir `organizationId` em todas as operaÃ§Ãµes de dados
- **NUNCA** permitir acesso cross-organization sem validaÃ§Ã£o explÃ­cita
- **OBRIGATÃ“RIO** validar tenant isolation em todos os mÃ©todos de repository
- **AUTOMÃTICO** aplicar filtros de organizaÃ§Ã£o em todas as queries

### **2. ISOLAMENTO DE RESPONSABILIDADES (SRP)**
- **Uma responsabilidade por classe/serviÃ§o/mÃ³dulo**
- **Business logic isolada** em Domain Services
- **Data access isolado** em Repositories
- **Infrastructure isolada** em Providers
- **API logic isolada** em Routes com Adapters

### **3. DEPENDENCY INJECTION OBRIGATÃ“RIO**
- **Todas as dependÃªncias injetadas** via constructor
- **Interfaces sempre** para abstraÃ§Ãµes
- **ServiceContainer** para resolution
- **Organization-specific** service resolution

---

## ğŸ›ï¸ **ARQUITETURA MANDATÃ“RIA**

### **ESTRUTURA DE CAMADAS**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   API Routes        â”‚ â† HTTP/REST interface apenas
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   API Adapters      â”‚ â† Bridge para Domain Services
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Domain Services   â”‚ â† Business logic isolada
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Repository        â”‚ â† Data access abstraction
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Infrastructure    â”‚ â† External services (DB, LLM, Storage)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### **NUNCA FAÃ‡A:**
- âŒ Business logic em API routes
- âŒ Data access direto em Domain Services
- âŒ Queries sem organizationId
- âŒ Hard-coded providers
- âŒ Direct database calls fora do Repository
- âŒ Cross-domain dependencies

### **SEMPRE FAÃ‡A:**
- âœ… Use Domain Services para business logic
- âœ… Use Repositories para data access
- âœ… Use ServiceContainer para DI
- âœ… Validate organization access
- âœ… Propagate ServiceContext
- âœ… Return OperationResult<T>

---

## ğŸ”’ **MULTI-TENANT SECURITY PATTERNS**

### **REPOSITORY OBRIGATÃ“RIO**
```typescript
// âœ… CORRETO - organizationId sempre presente
export interface Repository<T> {
  findById(id: string, organizationId: string): Promise<T | null>;
  create(entity: Omit<T, 'id'>, organizationId: string): Promise<T>;
  update(id: string, updates: Partial<T>, organizationId: string): Promise<T>;
  delete(id: string, organizationId: string): Promise<void>;
}

// âŒ ERRADO - sem organizationId
export interface BadRepository<T> {
  findById(id: string): Promise<T | null>; // NUNCA FAÃ‡A ISSO
}
```

### **DOMAIN SERVICE OBRIGATÃ“RIO**
```typescript
// âœ… CORRETO - TenantService base
export class ChatDomainService extends TenantService<Chat> {
  constructor(
    organizationId: string,
    private repository: Repository<Chat>
  ) {
    super(organizationId, repository);
  }

  async getChat(chatId: string, userId: string): Promise<OperationResult<Chat>> {
    // Sempre validate organization access
    const chat = await this.repository.findById(chatId, this.organizationId);
    if (!chat) throw new Error('Chat not found');
    
    await this.validateOrganizationAccess(chat.organizationId);
    return { success: true, data: chat, context: this.createContext(userId) };
  }
}
```

### **VALIDATION OBRIGATÃ“RIA**
```typescript
// âœ… SEMPRE validar tenant access
protected async validateOrganizationAccess(resourceOrgId: string): Promise<void> {
  if (resourceOrgId !== this.organizationId) {
    throw new Error('Access denied: Resource belongs to different organization');
  }
}

// âœ… SEMPRE usar organization context
protected createContext(userId?: string): ServiceContext {
  return {
    organizationId: this.organizationId,
    userId,
    timestamp: new Date(),
    requestId: crypto.randomUUID()
  };
}
```

---

## ğŸ”§ **SERVICE LAYER PATTERNS**

### **TENANT SERVICE BASE**
```typescript
// âœ… OBRIGATÃ“RIO - Todos domain services devem estender
export abstract class TenantService<T> {
  constructor(
    protected organizationId: string,
    protected repository: Repository<T>,
    protected config: ServiceConfig = {}
  ) {}

  protected async withTransaction<R>(operation: () => Promise<R>): Promise<R> {
    // Transaction management
  }

  protected async checkPermissions(userId: string, action: string): Promise<void> {
    // Permission validation
  }

  protected async validateOrganizationAccess(resourceOrgId: string): Promise<void> {
    // Tenant isolation validation
  }
}
```

### **REPOSITORY PATTERN**
```typescript
// âœ… Interface obrigatÃ³ria
export interface Repository<T> {
  // SEMPRE incluir organizationId
  findById(id: string, organizationId: string): Promise<T | null>;
  findByUserId(userId: string, organizationId: string): Promise<T[]>;
  create(entity: Omit<T, 'id'>, organizationId: string): Promise<T>;
  update(id: string, updates: Partial<T>, organizationId: string): Promise<T>;
  delete(id: string, organizationId: string): Promise<void>;
}

// âœ… Base implementation obrigatÃ³ria
export abstract class BaseRepositoryImpl<T> implements Repository<T> {
  protected ensureTenantIsolation(query: any, organizationId: string): any {
    if (!query.where) query.where = {};
    query.where.organizationId = organizationId;
    return query;
  }

  protected validateOrganizationId(organizationId: string): void {
    if (!organizationId) {
      throw new Error('Organization ID is required for all repository operations');
    }
  }
}
```

### **DEPENDENCY INJECTION**
```typescript
// âœ… ServiceContainer obrigatÃ³rio
export class ServiceContainerImpl implements ServiceContainer {
  resolveWithContext<T>(key: string, context: ServiceContext): T {
    // Try organization-specific service first
    const organizationKey = `${key}:${context.organizationId}`;
    if (this.services.has(organizationKey)) {
      return this.resolve(organizationKey);
    }
    return this.resolve(key); // Fallback
  }
}

// âœ… Sempre resolver com context
const chatService = serviceContainer.resolveWithContext<ChatDomainService>(
  'chatService', 
  { organizationId: 'org-123', userId: 'user-456' }
);
```

---

## ğŸ”Œ **PROVIDER ABSTRACTION PATTERNS**

### **LLM PROVIDER INTERFACE**
```typescript
// âœ… OBRIGATÃ“RIO - Provider abstraction
export interface LLMProvider {
  name: string;
  generateResponse(input: LLMRequest): Promise<LLMResponse>;
  generateStream(input: LLMRequest): AsyncGenerator<LLMChunk>;
  validateConfig(config: LLMConfig): Promise<boolean>;
}

// âœ… NUNCA hard-code providers
// âŒ ERRADO
const response = await openai.chat.completions.create({...});

// âœ… CORRETO
const provider = container.resolve<LLMProvider>('llmProvider');
const response = await provider.generateResponse(request);
```

### **STORAGE PROVIDER INTERFACE**
```typescript
// âœ… OBRIGATÃ“RIO - Storage abstraction
export interface StorageProvider {
  upload(file: File, path: string): Promise<string>;
  download(path: string): Promise<Buffer>;
  delete(path: string): Promise<void>;
  getSignedUrl(path: string, expiry: number): Promise<string>;
}
```

---

## ğŸ“Š **ERROR HANDLING PATTERNS**

### **OPERATION RESULT OBRIGATÃ“RIO**
```typescript
// âœ… SEMPRE retornar OperationResult
export interface OperationResult<T> {
  success: boolean;
  data?: T;
  error?: string;
  context: ServiceContext;
}

// âœ… Pattern obrigatÃ³rio
async createChat(request: CreateChatRequest): Promise<OperationResult<Chat>> {
  const context = this.createContext(request.userId);
  
  try {
    // Business logic
    const chat = await this.repository.create(data, this.organizationId);
    
    return {
      success: true,
      data: chat,
      context
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      context
    };
  }
}
```

### **FAIL-SAFE DEFAULTS**
```typescript
// âœ… SEMPRE configurar defaults seguros
this.config = {
  enableLogging: true,    // Default seguro
  timeout: 30000,        // Timeout razoÃ¡vel
  retryAttempts: 3,      // Resilience
  ...config
};

// âœ… RETRY com exponential backoff
protected async retry<T>(operation: () => Promise<T>): Promise<T> {
  for (let i = 0; i < attempts; i++) {
    try {
      return await operation();
    } catch (error) {
      if (i < attempts - 1) {
        await this.delay(Math.pow(2, i) * 1000); // Exponential backoff
      }
    }
  }
  throw lastError;
}
```

---

## ğŸ§ª **TESTING PATTERNS**

### **MOCKABLE DEPENDENCIES**
```typescript
// âœ… SEMPRE design para testabilidade
export class ChatDomainService extends TenantService<Chat> {
  constructor(
    organizationId: string,
    private repository: Repository<Chat>,      // Mockable
    private quotaService: QuotaService,        // Mockable
    private aiProvider: LLMProvider            // Mockable
  ) {
    super(organizationId, repository);
  }
}

// âœ… Easy mocking
const mockRepository = {
  create: jest.fn(),
  findById: jest.fn(),
  // ... other mocks
};

const service = new ChatDomainService('org-123', mockRepository, mockQuota, mockAI);
```

### **UNIT TEST PATTERN**
```typescript
// âœ… Test pattern obrigatÃ³rio
describe('ChatDomainService', () => {
  let service: ChatDomainService;
  let mockRepository: jest.Mocked<Repository<Chat>>;

  beforeEach(() => {
    mockRepository = {
      create: jest.fn(),
      findById: jest.fn(),
      // ... other mocks
    };
    
    service = new ChatDomainService('org-123', mockRepository);
  });

  test('should create chat with proper organization isolation', async () => {
    const result = await service.createChat({
      userId: 'user-123',
      title: 'Test Chat'
    });

    expect(result.success).toBe(true);
    expect(mockRepository.create).toHaveBeenCalledWith(
      expect.objectContaining({
        organizationId: 'org-123'
      }),
      'org-123'
    );
  });
});
```

---

## ğŸ“ **ESTRUTURA DE ARQUIVOS OBRIGATÃ“RIA**

### **SERVICE LAYER ORGANIZATION**
```
lib/services/
â”œâ”€â”€ base/
â”‚   â”œâ”€â”€ tenant-service.ts          â† Base para todos services
â”‚   â””â”€â”€ service-config.ts          â† ConfiguraÃ§Ãµes base
â”œâ”€â”€ repositories/
â”‚   â”œâ”€â”€ base-repository.ts         â† Repository interface
â”‚   â”œâ”€â”€ chat-repository.ts         â† Chat data access
â”‚   â””â”€â”€ message-repository.ts      â† Message data access
â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ chat-domain-service.ts     â† Chat business logic
â”‚   â”œâ”€â”€ document-domain-service.ts â† Document business logic
â”‚   â””â”€â”€ companion-domain-service.tsâ† Companion business logic
â”œâ”€â”€ providers/
â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”œâ”€â”€ base-llm-provider.ts   â† LLM interface
â”‚   â”‚   â”œâ”€â”€ openai-provider.ts     â† OpenAI implementation
â”‚   â”‚   â””â”€â”€ azure-provider.ts      â† Azure implementation
â”‚   â””â”€â”€ storage/
â”‚       â”œâ”€â”€ base-storage-provider.ts
â”‚       â”œâ”€â”€ s3-provider.ts
â”‚       â””â”€â”€ azure-blob-provider.ts
â”œâ”€â”€ container/
â”‚   â””â”€â”€ service-container.ts       â† Dependency injection
â”œâ”€â”€ adapters/
â”‚   â”œâ”€â”€ chat-api-adapter.ts        â† API bridge
â”‚   â””â”€â”€ document-api-adapter.ts    â† API bridge
â”œâ”€â”€ types/
â”‚   â””â”€â”€ service-context.ts         â† Common types
â””â”€â”€ index.ts                       â† Export organization
```

### **API ORGANIZATION**
```
app/api/
â”œâ”€â”€ chat/
â”‚   â””â”€â”€ route.ts                   â† Use ChatApiAdapter
â”œâ”€â”€ documents/
â”‚   â””â”€â”€ route.ts                   â† Use DocumentApiAdapter
â””â”€â”€ companions/
    â””â”€â”€ route.ts                   â† Use CompanionApiAdapter
```

---

## ğŸ”§ **MIGRATION PATTERNS**

### **GRADUAL ADOPTION**
```typescript
// âœ… Pattern para migrar APIs existentes
export async function POST(request: Request) {
  const session = await auth();
  if (!session?.user) {
    return new ChatSDKError('unauthorized:chat').toResponse();
  }

  try {
    // âœ… Use adapter para migraÃ§Ã£o gradual
    const adapter = await createChatApiAdapter(session);
    const requestBody = await request.json();
    const result = await adapter.createChatFromRequest(requestBody);
    
    if (result.success) {
      return Response.json({ chatId: result.chatId });
    } else {
      return Response.json({ error: result.error }, { status: 400 });
    }
  } catch (error) {
    return Response.json({ error: 'Internal server error' }, { status: 500 });
  }
}
```

### **BACKWARD COMPATIBILITY**
```typescript
// âœ… Manter compatibilidade durante migraÃ§Ã£o
export class ChatApiAdapter {
  // âœ… MÃ©todos que mantÃªm interface existente
  async createChatFromRequest(requestBody: PostRequestBody) {
    // Converte para domain service call
    const result = await this.chatService.createChat({
      userId: this.session.user!.id,
      title: requestBody.title,
      // ... outros campos
    });
    
    // Retorna formato esperado pela API existente
    return {
      success: result.success,
      chatId: result.data?.id,
      error: result.error
    };
  }
}
```

---

## ğŸš¨ **VALIDAÃ‡ÃƒO E ENFORCEMENT**

### **ANTES DE CADA COMMIT:**
1. âœ… Verificar se `organizationId` estÃ¡ presente em todas as queries
2. âœ… Confirmar que business logic estÃ¡ em Domain Services
3. âœ… Validar que repositories implementam tenant isolation
4. âœ… Checar se dependencies sÃ£o injetadas via constructor
5. âœ… Confirmar que retorna `OperationResult<T>`
6. âœ… Verificar se hÃ¡ testes unitÃ¡rios para novos services

### **CODE REVIEW CHECKLIST:**
- [ ] `organizationId` obrigatÃ³rio em todos mÃ©todos de repository?
- [ ] Business logic isolada em Domain Service?
- [ ] Dependency injection configurada?
- [ ] Tenant validation implementada?
- [ ] Error handling com `OperationResult<T>`?
- [ ] Tests unitÃ¡rios incluÃ­dos?
- [ ] Documentation atualizada?

### **AUTOMATED CHECKS:**
```typescript
// âœ… Lint rules sugeridas
{
  "rules": {
    "no-direct-db-access": "error",        // Proibir DB direto
    "require-organization-id": "error",    // Exigir organizationId
    "no-hardcoded-providers": "error",     // Proibir providers hard-coded
    "require-dependency-injection": "error" // Exigir DI
  }
}
```

---

## ğŸ¯ **RESUMO EXECUTIVO**

### **DIRETRIZES INEGOCIÃVEIS:**
1. **Multi-tenancy rigoroso** - `organizationId` sempre
2. **Isolamento total** - SRP em todas as classes
3. **Dependency injection** - AbstraÃ§Ãµes sempre
4. **Fail-safe defaults** - Resilience em tudo
5. **Testabilidade mÃ¡xima** - Easy mocking
6. **Provider abstraction** - BYOC ready
7. **Gradual migration** - Backward compatibility

### **BENEFÃCIOS GARANTIDOS:**
- ğŸ”’ **Zero vazamento** entre organizations
- ğŸ§ª **90%+ testabilidade** com mocking fÃ¡cil
- ğŸ”„ **Flexibilidade total** para BYOC
- ğŸ“ˆ **Escalabilidade** sem refactor
- ğŸ›¡ï¸ **SeguranÃ§a** by design
- ğŸš€ **Performance** otimizada

---

**ğŸ“‹ LEMBRE-SE: Estas diretrizes sÃ£o OBRIGATÃ“RIAS para todas as mudanÃ§as no cÃ³digo. Qualquer desvio deve ser justificado e aprovado pela arquitetura.**

**ğŸ¯ OBJETIVO: Garantir que o Humana Companions seja a plataforma multi-tenant mais robusta e flexÃ­vel do mercado.** 